#ifndef MASK_GH
#define MASK_GH

#include "listex.gh"

inductive mask_t = MaskTopMinus(list<pair<void *, mask_t> >) | MaskBotPlus(list<pair<void *, mask_t> >) | MaskEmp;

fixpoint bool is_same_mask_node(pair<void *, mask_t> mn, pair<void *, mask_t> mn1) { return fst(mn) == fst(mn1); }

fixpoint pair<void *, mask_t> mask_node_merge(pair<void *, mask_t> mn, pair<void *, mask_t> mn1);
lemma_auto void mask_node_merge_def(pair<void *, mask_t> mn, pair<void *, mask_t> mn1);
  requires true;
  ensures mask_node_merge(mn, mn1) == (fst(mn) == fst(mn1) ? pair(fst(mn), mask_union(snd(mn), snd(mn1))) : mn);

fixpoint pair<void *, mask_t> mask_node_diff(pair<void *, mask_t> mn, pair<void *, mask_t> mn1);
lemma_auto void mask_node_diff_def(pair<void *, mask_t> mn, pair<void *, mask_t> mn1);
  requires true;
  ensures mask_node_diff(mn, mn1) == (fst(mn) == fst(mn1) ? pair(fst(mn), mask_diff(snd(mn), snd(mn1))) : mn);

fixpoint pair<void *, mask_t> mask_node_isect(pair<void *, mask_t> mn, pair<void *, mask_t> mn1);
lemma_auto void mask_node_isect_def(pair<void *, mask_t> mn, pair<void *, mask_t> mn1);
  requires true;
  ensures mask_node_isect(mn, mn1) == (fst(mn) == fst(mn1) ? pair(fst(mn), mask_isect(snd(mn), snd(mn1))) : pair(fst(mn), MaskBotPlus({})));

fixpoint list<pair<void *, mask_t> > mask_node_list_merge(list<pair<void *, mask_t> > mns) {
  switch(mns) {
    case nil: return nil;
    case cons(h, t): return switch(get_pred((is_same_mask_node)(h), mask_node_list_merge(t))) {
      case none: return cons(h, mask_node_list_merge(t));
      case some(mn): return cons(mask_node_merge(h, mn), remove(mn, mask_node_list_merge(t)));
    };
  }
}

fixpoint pair<void *, mask_t> mask_node_diff_list(list<pair<void *, mask_t> > mns, pair<void *, mask_t> mn) {
  return fold_left(mn, mask_node_diff, mns);
}

fixpoint pair<void *, mask_t> mask_node_isect_list(list<pair<void *, mask_t> > mns, pair<void *, mask_t> mn) {
  return exists(mns, (is_same_mask_node)(mn)) ?
    fold_left(mn, mask_node_isect, filter((is_same_mask_node)(mn), mns)) : pair(fst(mn), MaskBotPlus({}));
}

fixpoint mask_t mask_union(mask_t m, mask_t m1) {
  switch(m) {
    case MaskTopMinus(mns): return switch(m1) {
      case MaskTopMinus(mns1): return MaskTopMinus(map((mask_node_isect_list)(mns1), mns));
      case MaskBotPlus(mns1): return MaskTopMinus(map((mask_node_diff_list)(mns1), mns));
      case MaskEmp: return m;
    };
    case MaskBotPlus(mns): return switch(m1) {
      case MaskTopMinus(mns1): return MaskTopMinus(map((mask_node_diff_list)(mns), mns1));
      case MaskBotPlus(mns1): return MaskBotPlus(mask_node_list_merge(append(mns, mns1)));
      case MaskEmp: return m;
    };
    case MaskEmp: return m1;
  }
}

fixpoint mask_t mask_diff(mask_t m, mask_t m1) {
  switch(m) {
    case MaskTopMinus(mns): return switch(m1) {
      case MaskTopMinus(mns1): return MaskBotPlus(map((mask_node_diff_list)(mns), mns1));
      case MaskBotPlus(mns1): return MaskTopMinus(mask_node_list_merge(append(mns, mns1)));
      case MaskEmp: return m;
    };
    case MaskBotPlus(mns): return switch(m1) {
      case MaskTopMinus(mns1): return MaskBotPlus(map((mask_node_isect_list)(mns1), mns));
      case MaskBotPlus(mns1): return MaskBotPlus(map((mask_node_diff_list)(mns1), mns));
      case MaskEmp: return m;
    };
    case MaskEmp: return m;
  }
}

fixpoint mask_t mask_isect(mask_t m, mask_t m1) {
  switch(m) {
    case MaskTopMinus(mns): return switch(m1) {
      case MaskTopMinus(mns1): return MaskTopMinus(mask_node_list_merge(append(mns, mns1)));
      case MaskBotPlus(mns1): return MaskBotPlus(map((mask_node_diff_list)(mns), mns1));
      case MaskEmp: return MaskBotPlus({});
    };
    case MaskBotPlus(mns): return switch(m1) {
      case MaskTopMinus(mns1): return MaskBotPlus(map((mask_node_diff_list)(mns1), mns));
      case MaskBotPlus(mns1): return MaskBotPlus(map((mask_node_isect_list)(mns1), mns));
      case MaskEmp: return MaskBotPlus({});
    };
    case MaskEmp: return MaskBotPlus({});
  }
}

// m <= m1
fixpoint bool mask_is_sub(mask_t m, mask_t m1) {
  return mask_diff(m, m1) == MaskBotPlus({});
}

lemma void mask_diff_eq_isect_diff(mask_t m, mask_t m1);
  requires true;
  ensures mask_diff(m, m1) == mask_diff(m, mask_isect(m, m1));

#endif