#ifndef NONATOMIC_INV_GH
#define NONATOMIC_INV_GH

#include "listex.gh"

abstract_type thread_id_t;
inductive namespace_t = Nshr | Nrust;
inductive thread_local_namespace_t = Tlns(thread_id_t pool, namespace_t ns, list<void *> l);

predicate nonatomic_inv_complement_token(thread_id_t pool, namespace_t ns, list<void *> ls);
predicate nonatomic_inv_token(thread_id_t pool, namespace_t ns, list<void *> ls);

lemma void nonatomic_inv_complement_token_split(thread_id_t pool, namespace_t ns, list<void *> to_split);
  requires distinct(to_split) == true &*& nonatomic_inv_complement_token(pool, ns, ?ls) &*& intersection(ls, to_split) == nil;
  ensures nonatomic_inv_complement_token(pool, ns, append(to_split, ls)) &*& nonatomic_inv_token(pool, ns, to_split);

lemma void nonatomic_inv_complement_token_merge(thread_id_t pool, namespace_t ns, list<void *> to_merge);
  requires nonatomic_inv_complement_token(pool, ns, ?ls) &*& nonatomic_inv_token(pool, ns, to_merge); //&*& subset(to_merge, ls) == true; This is a consequence of nonatomic_inv_complement_token_split lemma
  ensures nonatomic_inv_complement_token(pool, ns, remove_all(to_merge, ls));

lemma void nonatomic_inv_token_split(thread_id_t pool, namespace_t ns, list<void *> ls, list<void *> to_split);
  requires distinct(to_split) == true &*& nonatomic_inv_token(pool, ns, ls) &*& subset(to_split, ls) == true;
  ensures nonatomic_inv_token(pool, ns, remove_all(to_split, ls)) &*& nonatomic_inv_token(pool, ns, to_split);

lemma void nonatomic_inv_token_merge(thread_id_t pool, namespace_t ns, list<void *> ls, list<void *> to_merge);
  requires nonatomic_inv_token(pool, ns, ls) &*& nonatomic_inv_token(pool, ns, to_merge);
  ensures nonatomic_inv_token(pool, ns, append(to_merge, ls));

#endif